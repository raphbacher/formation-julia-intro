{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction to Julia\n\n\nThe goal of this website is to provide an overview and an Introduction to the scientific programming language Julia.\nIt relies extensively on resources provided by the Julia community and in particular the \nJulia website\n, the \nJulia docs\n and material from the \nJuliaBox tutorials\n.\n\n\nThis website does not seek to be provide an exhaustive view of the language (see notably the \njulia docs\n for a very thorough review), but it can hopefully contribute to ease the access to Julia for some beginners.\n\n\nWhat is Julia\n\n\nJulia is a programming language created in 2009 by a few computer scientists notably at MIT.\nIt has its first public version in 2012 and hit its first stable version 1.0 in August 2018.\n\n\nBelow is exposed the Manifesto of the first public release in 2012 :\n\n\n\n\nWe want a language that\u2019s open source, with a liberal license. We want the speed of C with the dynamism of Ruby. We want a language that\u2019s homoiconic, with true macros like Lisp, but with obvious, familiar mathematical notation like Matlab. We want something as usable for general programming as Python, as easy for statistics as R, as natural for string processing as Perl, as powerful for linear algebra as Matlab, as good at gluing programs together as the shell. Something that is dirt simple to learn, yet keeps the most serious hackers happy. We want it interactive and we want it compiled.\n\n\n\n\nFor what and whom ?\n\n\nThe creation of Julia was motivated by the observation of a so-called \"Two languages problem\" in scientific computing.\nThis problem is driven by the fact that researchers need high level syntax and dynamism to explore complex and novel ideas, which can be provided by languages such as Python, R, Matlab, but may often need at some point to translate to some fast low-level language (usually Fortran/C).\n\n\nJulia was thus designed to those in scientific computing/data science (but also in other applications as it has grown into a general purpose language such as Python) that need to develop new efficient algorithms.\n\n\nAs it is a new language with a growing but still smaller ecosystem than e.g. Python or R, it is maybe less attractive for now for scientists that are only code/libraries users (even if in some domains the Julia ecosystem is already state of art such as Differential Equations, Optimization,...  and there exists possibility to connect easily to other language ecosystems, see \nthis page\n )\n\n\nWhat does it look like\n\n\nusing\n \nLinearAlgebra\n \n#load a library\n\n\n\nA\n \n=\n \nrand\n(\n10\n,\n10\n)\n \n# create a random matrix A of size 10 by 10\n\n\nY\n \n=\n \nrand\n(\n10\n)\n \n# create a random vector Y of size 10\n\n\n\nX\n \n=\n \nA\n\\\nY\n \n# resolve Y=AX\n\n\n\n\n\n\nfunction\n \nadd\n(\na\n,\nb\n)\n \n# define a function `add`\n\n  \nreturn\n \na\n+\nb\n\n\nend\n\n\n\nadd\n(\n3\n,\n4\n)\n \n# apply the function `add` to 3 and 4\n\n\n\n\n\n\nA tool for doing better science\n\n\nHigh level and efficient\n\n\nBy tackling the two language problems, Julia can allow better interaction between researchers and research engineers (see e.g. this very interesting \nvideo\n about the rise of the Reasearch Software Engineer) by becoming a lingua franca.\n\n\nBuild for collaboration\n\n\nJulia is a language that really encourages collaboration and factorization of code, by virtue of its design.\n\n\n\n\nA Julia Package is almost always synonym of a git/Github repo\n\n\nMultiple dispatch calls for generic programming.\n\n\nAnd allows very good composition of packages, where the total is more than the sum of the parts (see e.g. \nMeasurements.jl\n to get precision for all your packages, \nForwardDiff.jl\n to Automatic Derivation,...)\n\n\n\n\nAlso the youth of the language implies that the ecosystem is not (yet) fragmented (it also means that is easier to impact the ecosystem parts that concerns you, a large part of Julia contributors are non computer sciences PhD/postdocs )", 
            "title": "Home"
        }, 
        {
            "location": "/#introduction-to-julia", 
            "text": "The goal of this website is to provide an overview and an Introduction to the scientific programming language Julia.\nIt relies extensively on resources provided by the Julia community and in particular the  Julia website , the  Julia docs  and material from the  JuliaBox tutorials .  This website does not seek to be provide an exhaustive view of the language (see notably the  julia docs  for a very thorough review), but it can hopefully contribute to ease the access to Julia for some beginners.", 
            "title": "Introduction to Julia"
        }, 
        {
            "location": "/#what-is-julia", 
            "text": "Julia is a programming language created in 2009 by a few computer scientists notably at MIT.\nIt has its first public version in 2012 and hit its first stable version 1.0 in August 2018.  Below is exposed the Manifesto of the first public release in 2012 :   We want a language that\u2019s open source, with a liberal license. We want the speed of C with the dynamism of Ruby. We want a language that\u2019s homoiconic, with true macros like Lisp, but with obvious, familiar mathematical notation like Matlab. We want something as usable for general programming as Python, as easy for statistics as R, as natural for string processing as Perl, as powerful for linear algebra as Matlab, as good at gluing programs together as the shell. Something that is dirt simple to learn, yet keeps the most serious hackers happy. We want it interactive and we want it compiled.", 
            "title": "What is Julia"
        }, 
        {
            "location": "/#for-what-and-whom", 
            "text": "The creation of Julia was motivated by the observation of a so-called \"Two languages problem\" in scientific computing.\nThis problem is driven by the fact that researchers need high level syntax and dynamism to explore complex and novel ideas, which can be provided by languages such as Python, R, Matlab, but may often need at some point to translate to some fast low-level language (usually Fortran/C).  Julia was thus designed to those in scientific computing/data science (but also in other applications as it has grown into a general purpose language such as Python) that need to develop new efficient algorithms.  As it is a new language with a growing but still smaller ecosystem than e.g. Python or R, it is maybe less attractive for now for scientists that are only code/libraries users (even if in some domains the Julia ecosystem is already state of art such as Differential Equations, Optimization,...  and there exists possibility to connect easily to other language ecosystems, see  this page  )", 
            "title": "For what and whom ?"
        }, 
        {
            "location": "/#what-does-it-look-like", 
            "text": "using   LinearAlgebra   #load a library  A   =   rand ( 10 , 10 )   # create a random matrix A of size 10 by 10  Y   =   rand ( 10 )   # create a random vector Y of size 10  X   =   A \\ Y   # resolve Y=AX   function   add ( a , b )   # define a function `add` \n   return   a + b  end  add ( 3 , 4 )   # apply the function `add` to 3 and 4", 
            "title": "What does it look like"
        }, 
        {
            "location": "/#a-tool-for-doing-better-science", 
            "text": "", 
            "title": "A tool for doing better science"
        }, 
        {
            "location": "/#high-level-and-efficient", 
            "text": "By tackling the two language problems, Julia can allow better interaction between researchers and research engineers (see e.g. this very interesting  video  about the rise of the Reasearch Software Engineer) by becoming a lingua franca.", 
            "title": "High level and efficient"
        }, 
        {
            "location": "/#build-for-collaboration", 
            "text": "Julia is a language that really encourages collaboration and factorization of code, by virtue of its design.   A Julia Package is almost always synonym of a git/Github repo  Multiple dispatch calls for generic programming.  And allows very good composition of packages, where the total is more than the sum of the parts (see e.g.  Measurements.jl  to get precision for all your packages,  ForwardDiff.jl  to Automatic Derivation,...)   Also the youth of the language implies that the ecosystem is not (yet) fragmented (it also means that is easier to impact the ecosystem parts that concerns you, a large part of Julia contributors are non computer sciences PhD/postdocs )", 
            "title": "Build for collaboration"
        }, 
        {
            "location": "/15_09_2018_training/", 
            "text": "Infos related to  November 15 Training\n\n\nOutline\n\n\n\n\n9am : Introduction (2h)\n\n\n\n\nA bit of history : The Two Languages Problem\n\n\nThe Julia language\n\n\nSyntax and structures\n\n\nLinear Algebra\n\n\nPlotting\n\n\nMultiple Dispatch\n\n\n\n\n11:00am 10mn break\n\n\n11:10am Julia Ecosystem (1h20)\n\n\n\n\nOnline resources\n\n\nDevelopment Tools (Juno/Vscode/Jupyter)\n\n\nInstall/Develop packages\n\n\n\n\n\n\n2:00pm Practical works (1n30)\n\n\n3:30pm 10mn break\n\n\n3:40pm Practical works (1n20)\n\n\n5pm : End\n\n\n\n\nVenue\n\n\nB\u00e2timent IMAG, 700 avenue Centrale, Domaine Universitaire - 38401 St Martin d'H\u00e8res.\n\n\nThe training room is on the ground floor (no badge needed), on your right when entering main entrance.\n\n\nPreparation\n\n\nYou are encouraged to come with your personnal computer, \nideally with Julia already installed\n. To install Julia go to\n\nhttps://julialang.org/downloads/\n to download and follow instructions there \nhttps://julialang.org/downloads/platform.html#generic-binaries\n. For this session we will use the current stable release v1.0.2.\n\n\nFor those who can't bring a laptop, computers with the Ubuntu system will be available.\nIf you want to explore Julia without installing anything you can also go to \nhttps://juliabox.com\n and play with the notebooks available online.", 
            "title": "November 15 training"
        }, 
        {
            "location": "/15_09_2018_training/#infos-related-to-november-15-training", 
            "text": "", 
            "title": "Infos related to  November 15 Training"
        }, 
        {
            "location": "/15_09_2018_training/#outline", 
            "text": "9am : Introduction (2h)   A bit of history : The Two Languages Problem  The Julia language  Syntax and structures  Linear Algebra  Plotting  Multiple Dispatch   11:00am 10mn break  11:10am Julia Ecosystem (1h20)   Online resources  Development Tools (Juno/Vscode/Jupyter)  Install/Develop packages    2:00pm Practical works (1n30)  3:30pm 10mn break  3:40pm Practical works (1n20)  5pm : End", 
            "title": "Outline"
        }, 
        {
            "location": "/15_09_2018_training/#venue", 
            "text": "B\u00e2timent IMAG, 700 avenue Centrale, Domaine Universitaire - 38401 St Martin d'H\u00e8res.  The training room is on the ground floor (no badge needed), on your right when entering main entrance.", 
            "title": "Venue"
        }, 
        {
            "location": "/15_09_2018_training/#preparation", 
            "text": "You are encouraged to come with your personnal computer,  ideally with Julia already installed . To install Julia go to https://julialang.org/downloads/  to download and follow instructions there  https://julialang.org/downloads/platform.html#generic-binaries . For this session we will use the current stable release v1.0.2.  For those who can't bring a laptop, computers with the Ubuntu system will be available.\nIf you want to explore Julia without installing anything you can also go to  https://juliabox.com  and play with the notebooks available online.", 
            "title": "Preparation"
        }, 
        {
            "location": "/first_steps/", 
            "text": "Get Julia\n\n\nTry Julia online\n\n\nYou can try Julia online and for free at \nhttp://juliabox.com\n.\nYou will need to create a account (or log with your Github or Google account)\nOnce your are connected, you will be able to launch a jupyter server (the Launch button). You can then go .\nYou can if you want, follow an online presentation of these notebooks here : \nhttps://www.youtube.com/watch?v=fMa1qSg_LxA\n\n\nInstall on your machine\n\n\nYou can download the Julia binaries from \nhttp://julialang.org/downloads\n\nand follow instruction \nhere\n.\n\n\nIf you want a all-in-one package (meaning coming with a list of curated Julia packages) you can use the JuliaPro distribution (similar to e.g. Anaconda for Python). The JuliaPro distribution is free but requires a registration for downloading and installing new packages (note that as of November 2018 I personally recommend using directly the Julia installer as the JuliaPro list of packages is quite limited right now and thus requires some manipulations to access the whole ecosystem)\n\n\nThe REPL\n\n\nOnce Julia is installed, you can launch the Julia REPL (\"Read Eval Print Line\", similar to the R or Python/IPython command line).\n\n\nTo launch the Julia REPL, just type \njulia\n in a terminal in Linux/Mac if you have indeed put julia in your path (see \nhere\n)\n\n\nThe REPL of Julia is a very powerful tool to interact with Julia. It provides several \"modes\"\n\n\n\n\nShell mode : start with a \";\" (e.g. \n;ls\n )\n\n\nPackage mode : start with a \"]\" (e.g. \n]add Plots\n )\n\n\nHelp mode : start with a \"?\" (e.g. \n?cos\n )\n\n\n\n\nYou can then write directly your command e.g.\n\n\n4+3\n\n\n\n\n\nand see the result immediately.\n\n\nIn a file\n\n\nWrite the following in a \ntoto.jl\n file :\n\n\nfunction\n \naddfunc\n(\na\n,\nb\n)\n\n    \nreturn\n \na\n+\nb\n\n\nend\n\n\n\nprint\n(\naddfunc\n(\n3\n,\n4\n))\n\n\n\n\n\n\nFrom a terminal you can then execute this file by typing\n\n\njulia toto.jl\n\n\n\n\n\nNote that you can also execute this file in the REPL by typing \ninclude(toto.jl)\n\n\nExplore the language\n\n\nThe Julia community and Julia Computing provide a extensive \nlist of introductory notebooks\n (a subset of which are exploited in the \ntutorials section\n)", 
            "title": "First steps"
        }, 
        {
            "location": "/first_steps/#get-julia", 
            "text": "", 
            "title": "Get Julia"
        }, 
        {
            "location": "/first_steps/#try-julia-online", 
            "text": "You can try Julia online and for free at  http://juliabox.com .\nYou will need to create a account (or log with your Github or Google account)\nOnce your are connected, you will be able to launch a jupyter server (the Launch button). You can then go .\nYou can if you want, follow an online presentation of these notebooks here :  https://www.youtube.com/watch?v=fMa1qSg_LxA", 
            "title": "Try Julia online"
        }, 
        {
            "location": "/first_steps/#install-on-your-machine", 
            "text": "You can download the Julia binaries from  http://julialang.org/downloads \nand follow instruction  here .  If you want a all-in-one package (meaning coming with a list of curated Julia packages) you can use the JuliaPro distribution (similar to e.g. Anaconda for Python). The JuliaPro distribution is free but requires a registration for downloading and installing new packages (note that as of November 2018 I personally recommend using directly the Julia installer as the JuliaPro list of packages is quite limited right now and thus requires some manipulations to access the whole ecosystem)", 
            "title": "Install on your machine"
        }, 
        {
            "location": "/first_steps/#the-repl", 
            "text": "Once Julia is installed, you can launch the Julia REPL (\"Read Eval Print Line\", similar to the R or Python/IPython command line).  To launch the Julia REPL, just type  julia  in a terminal in Linux/Mac if you have indeed put julia in your path (see  here )  The REPL of Julia is a very powerful tool to interact with Julia. It provides several \"modes\"   Shell mode : start with a \";\" (e.g.  ;ls  )  Package mode : start with a \"]\" (e.g.  ]add Plots  )  Help mode : start with a \"?\" (e.g.  ?cos  )   You can then write directly your command e.g.  4+3  and see the result immediately.", 
            "title": "The REPL"
        }, 
        {
            "location": "/first_steps/#in-a-file", 
            "text": "Write the following in a  toto.jl  file :  function   addfunc ( a , b ) \n     return   a + b  end  print ( addfunc ( 3 , 4 ))   From a terminal you can then execute this file by typing  julia toto.jl  Note that you can also execute this file in the REPL by typing  include(toto.jl)", 
            "title": "In a file"
        }, 
        {
            "location": "/first_steps/#explore-the-language", 
            "text": "The Julia community and Julia Computing provide a extensive  list of introductory notebooks  (a subset of which are exploited in the  tutorials section )", 
            "title": "Explore the language"
        }, 
        {
            "location": "/ecosystem/", 
            "text": "The Julia ecosystem\n\n\nOnline ressources\n\n\nThe main Julia documentation is available \nhere\n\n\nA lot of ressources are referenced on the \nJulia website\n\n\nIn particular you can get all the example notebooks (also available in juliabox) \nhere\n\n\nNote :\n\n\n\n\nJulia has been publicly available since 2012 and it has only reached its first stable release 1.0 in August 2018 (all 0.x versions came with breaking changes), so lot of ressources over the web are still not accurate/pertinent for 1.0.\n\n\n\n\nDevelopment Tools :\n\n\nJuliaPro/JuliaBox\n\n\nJuliaPro is a distribution of curated packages for Julia (as Anaconda for Python, or Matlab with a set of toolboxes). It is provided freely (but requires a registration to download and install packages) by JuliaComputing.\n\n\nJuliabox is an online environment (based on Jupyter notebooks) with Julia (and some packages) preinstalled. You can also use it freely (or pay for more computational ressources). It also provides a large number of example notebooks to learn Julia.\n\n\nThe REPL\n\n\nWhen you launch the Julia REPL, you are running a Julia process. While this process is not stopped\n\n\nBy default variables defined in the REPL outside of a function or loop/block are \nglobal\n which means that for example  (in Julia 1.0.1) you must do that\n\n\na\n=\n2\n\n\nfor\n \ni\n \nin\n \n1\n:\n10\n\n  \n# a = a + 3 # will result in error\n\n  \nglobal\n \na\n \n=\n \na\n \n+\n3\n\n\nend\n\n\n\n\n\n\nIndeed to be able to write on a variable outside of the loop you need to acknowledge the fact that a is global , or put everything inside a function (which defines its own local scope).\n\n\nEditors\n\n\nYou can use any editor and the REPL but some tools (IDE) are developed in the community especially to ease data analysis and exploration.\n\n\nJupyter\n\n\nJulia works very well in Jupyter notebook (in fact the name Jupyter which remplaces the original IPython notebook comes from JU(lia)-PYT(hon)-R once it was realized that most of it concept was language-agnostic)\n\n\nJuno\n\n\nJuno is the \"official\" IDE of Julia.\nIt is in fact a customization of a generic code editor called Atom (which is developped by Github).\n\n\nVSCode\n\n\nVSCode is very similar to Atom (but developed as an open-source product by Microsoft).", 
            "title": "Tools"
        }, 
        {
            "location": "/ecosystem/#the-julia-ecosystem", 
            "text": "", 
            "title": "The Julia ecosystem"
        }, 
        {
            "location": "/ecosystem/#online-ressources", 
            "text": "The main Julia documentation is available  here  A lot of ressources are referenced on the  Julia website  In particular you can get all the example notebooks (also available in juliabox)  here  Note :   Julia has been publicly available since 2012 and it has only reached its first stable release 1.0 in August 2018 (all 0.x versions came with breaking changes), so lot of ressources over the web are still not accurate/pertinent for 1.0.", 
            "title": "Online ressources"
        }, 
        {
            "location": "/ecosystem/#development-tools", 
            "text": "", 
            "title": "Development Tools :"
        }, 
        {
            "location": "/ecosystem/#juliaprojuliabox", 
            "text": "JuliaPro is a distribution of curated packages for Julia (as Anaconda for Python, or Matlab with a set of toolboxes). It is provided freely (but requires a registration to download and install packages) by JuliaComputing.  Juliabox is an online environment (based on Jupyter notebooks) with Julia (and some packages) preinstalled. You can also use it freely (or pay for more computational ressources). It also provides a large number of example notebooks to learn Julia.", 
            "title": "JuliaPro/JuliaBox"
        }, 
        {
            "location": "/ecosystem/#the-repl", 
            "text": "When you launch the Julia REPL, you are running a Julia process. While this process is not stopped  By default variables defined in the REPL outside of a function or loop/block are  global  which means that for example  (in Julia 1.0.1) you must do that  a = 2  for   i   in   1 : 10 \n   # a = a + 3 # will result in error \n   global   a   =   a   + 3  end   Indeed to be able to write on a variable outside of the loop you need to acknowledge the fact that a is global , or put everything inside a function (which defines its own local scope).", 
            "title": "The REPL"
        }, 
        {
            "location": "/ecosystem/#editors", 
            "text": "You can use any editor and the REPL but some tools (IDE) are developed in the community especially to ease data analysis and exploration.", 
            "title": "Editors"
        }, 
        {
            "location": "/ecosystem/#jupyter", 
            "text": "Julia works very well in Jupyter notebook (in fact the name Jupyter which remplaces the original IPython notebook comes from JU(lia)-PYT(hon)-R once it was realized that most of it concept was language-agnostic)", 
            "title": "Jupyter"
        }, 
        {
            "location": "/ecosystem/#juno", 
            "text": "Juno is the \"official\" IDE of Julia.\nIt is in fact a customization of a generic code editor called Atom (which is developped by Github).", 
            "title": "Juno"
        }, 
        {
            "location": "/ecosystem/#vscode", 
            "text": "VSCode is very similar to Atom (but developed as an open-source product by Microsoft).", 
            "title": "VSCode"
        }, 
        {
            "location": "/tutorials/01_start_julia/", 
            "text": "Getting to know Julia\nThis notebook is meant to offer a crash course in Julia syntax to show you that Julia is lightweight and easy to use -- like your favorite high-level language!\n\n\nWe'll talk about\n\n\n\n\nStrings\n\n\nData structures\n\n\nLoops\n\n\nConditionals\n\n\nFunctions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStrings\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[1]:\n\n\n\n    \n\n\nstring1\n \n=\n \nHow many cats \n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[1]:\n\n\n\n\n\n\n\n\nHow many cats \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[2]:\n\n\n\n    \n\n\nstring2\n \n=\n \nis too many cats?\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[2]:\n\n\n\n\n\n\n\n\nis too many cats?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[3]:\n\n\n\n    \n\n\nstring\n(\nstring1\n,\n \nstring2\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[3]:\n\n\n\n\n\n\n\n\nHow many cats is too many cats?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[4]:\n\n\n\n    \n\n\n\ud83d\ude3a\n \n=\n \n10\n\n\nprintln\n(\nI don\nt know but \n$\ud83d\ude3a\n are too few!\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\nI don\nt know but 10 are too few!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote: Julia allows us to write super generic code, and \ud83d\ude3a is an example of this.\n\n\nThis allows us to write code like\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[5]:\n\n\n\n    \n\n\n\ud83d\ude3a\n \n=\n \n1\n\n\n\ud83d\ude00\n \n=\n \n0\n\n\n\ud83d\ude1e\n \n=\n \n-\n1\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[5]:\n\n\n\n\n\n\n\n\n-1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[6]:\n\n\n\n    \n\n\n\ud83d\ude3a\n \n+\n \n\ud83d\ude1e\n \n==\n \n\ud83d\ude00\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[6]:\n\n\n\n\n\n\n\n\ntrue\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nData structures\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTuples\nWe can create a tuple by enclosing an ordered collection of elements in \n( )\n.\n\n\nSyntax: \n\n\n(\nitem1\n,\n \nitem2\n,\n \n...\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[7]:\n\n\n\n    \n\n\nmyfavoriteanimals\n \n=\n \n(\npenguins\n,\n \ncats\n,\n \nsugargliders\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[7]:\n\n\n\n\n\n\n\n\n(\npenguins\n, \ncats\n, \nsugargliders\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[8]:\n\n\n\n    \n\n\nmyfavoriteanimals\n[\n1\n]\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[8]:\n\n\n\n\n\n\n\n\npenguins\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDictionaries\nIf we have sets of data related to one another, we may choose to store that data in a dictionary. To do this, we use the \nDict()\n function.\n\n\nSyntax:\n\n\nDict\n(\nkey1\n \n=\n \nvalue1\n,\n \nkey2\n \n=\n \nvalue2\n,\n \n...\n)\n\n\n\n\nA good example of a dictionary is a contacts list, where we associate names with phone numbers.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[9]:\n\n\n\n    \n\n\nmyphonebook\n \n=\n \nDict\n(\nJenny\n \n=\n \n867-5309\n,\n \nGhostbusters\n \n=\n \n555-2368\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[9]:\n\n\n\n\n\n\n\n\nDict{String,String} with 2 entries:\n  \nJenny\n        =\n \n867-5309\n\n  \nGhostbusters\n =\n \n555-2368\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[10]:\n\n\n\n    \n\n\nmyphonebook\n[\nJenny\n]\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[10]:\n\n\n\n\n\n\n\n\n867-5309\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArrays\nUnlike tuples, arrays are mutable. Unlike dictionaries, arrays contain ordered sequences of elements. \n\nWe can create an array by enclosing this sequence of elements in \n[ ]\n.\n\n\nSyntax: \n\n\n[\nitem1\n,\n \nitem2\n,\n \n...\n]\n\n\n\n\nFor example, we might create an array to keep track of my friends\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[11]:\n\n\n\n    \n\n\nmyfriends\n \n=\n \n[\nTed\n,\n \nRobyn\n,\n \nBarney\n,\n \nLily\n,\n \nMarshall\n]\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[11]:\n\n\n\n\n\n\n\n\n5-element Array{String,1}:\n \nTed\n     \n \nRobyn\n   \n \nBarney\n  \n \nLily\n    \n \nMarshall\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[12]:\n\n\n\n    \n\n\nfibonacci\n \n=\n \n[\n1\n,\n \n1\n,\n \n2\n,\n \n3\n,\n \n5\n,\n \n8\n,\n \n13\n]\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[12]:\n\n\n\n\n\n\n\n\n7-element Array{Int64,1}:\n  1\n  1\n  2\n  3\n  5\n  8\n 13\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[13]:\n\n\n\n    \n\n\nmixture\n \n=\n \n[\n1\n,\n \n1\n,\n \n2\n,\n \n3\n,\n \nTed\n,\n \nRobyn\n]\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[13]:\n\n\n\n\n\n\n\n\n6-element Array{Any,1}:\n 1       \n 1       \n 2       \n 3       \n  \nTed\n  \n  \nRobyn\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can also create arrays of other data structures, or multi-dimensional arrays.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[14]:\n\n\n\n    \n\n\nnumbers\n \n=\n \n[[\n1\n,\n \n2\n,\n \n3\n],\n \n[\n4\n,\n \n5\n],\n \n[\n6\n,\n \n7\n,\n \n8\n,\n \n9\n]]\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[14]:\n\n\n\n\n\n\n\n\n3-element Array{Array{Int64,1},1}:\n [1, 2, 3]   \n [4, 5]      \n [6, 7, 8, 9]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[15]:\n\n\n\n    \n\n\nrand\n(\n4\n,\n \n3\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[15]:\n\n\n\n\n\n\n\n\n4\u00d73 Array{Float64,2}:\n 0.41536   0.199777  0.224917\n 0.650967  0.455228  0.586753\n 0.811018  0.870951  0.879882\n 0.745686  0.579426  0.813446\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLoops\nfor\n loops\nThe syntax for a \nfor\n loop is\n\n\nfor\n \n*\nvar\n*\n \nin\n \n*\nloop\n \niterable\n*\n\n    \n*\nloop\n \nbody\n*\n\n\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[16]:\n\n\n\n    \n\n\nfor\n \nn\n \nin\n \n1\n:\n10\n\n    \nprintln\n(\nn\n)\n\n\nend\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nwhile\n loops\nThe syntax for a \nwhile\n is\n\n\nwhile\n \n*\ncondition\n*\n\n    \n*\nloop\n \nbody\n*\n\n\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[17]:\n\n\n\n    \n\n\nn\n \n=\n \n0\n\n\nwhile\n \nn\n \n \n10\n\n    \nn\n \n+=\n \n1\n\n    \nprintln\n(\nn\n)\n\n\nend\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConditionals\nwith \nif\nIn Julia, the syntax\n\n\nif\n \n*\ncondition\n \n1\n*\n\n    \n*\noption\n \n1\n*\n\n\nelseif\n \n*\ncondition\n \n2\n*\n\n    \n*\noption\n \n2\n*\n\n\nelse\n\n    \n*\noption\n \n3\n*\n\n\nend\n\n\n\n\nallows us to conditionally evaluate one of our options.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[18]:\n\n\n\n    \n\n\nx\n,\n \ny\n \n=\n \n43\n,\n42\n# Enter two numbers here!\n\n\nif\n \nx\n \n \ny\n\n    \nx\n\n\nelse\n\n    \ny\n\n\nend\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[18]:\n\n\n\n\n\n\n\n\n43\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nwith ternary operators\nFor this last block, we could instead use the ternary operator with the syntax\n\n\na\n \n?\n \nb\n \n:\n \nc\n\n\n\n\nwhich equates to\n\n\nif\n \na\n\n    \nb\n\n\nelse\n\n    \nc\n\n\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[19]:\n\n\n\n    \n\n\n(\nx\n \n \ny\n)\n \n?\n \nx\n \n:\n \ny\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[19]:\n\n\n\n\n\n\n\n\n43\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFunctions\nTopics:\n\n\n\n\nHow to declare a function\n\n\nDuck-typing in Julia\n\n\nMutating vs. non-mutating functions\n\n\nSome higher order functions\n\n\n\n\nHow to declare a function\nFirst way: with \nfunction\n and \nend\n keywords\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[20]:\n\n\n\n    \n\n\nfunction\n \nf\n(\nx\n)\n\n    \nx\n^\n2\n\n\nend\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[20]:\n\n\n\n\n\n\n\n\nf (generic function with 1 method)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSecond way: with \n=\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[21]:\n\n\n\n    \n\n\nf2\n(\nx\n)\n \n=\n \nx\n^\n2\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[21]:\n\n\n\n\n\n\n\n\nf2 (generic function with 1 method)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThird way: as an anonymous function\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[22]:\n\n\n\n    \n\n\nf3\n \n=\n \nx\n \n-\n \nx\n^\n2\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[22]:\n\n\n\n\n\n\n\n\n#3 (generic function with 1 method)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCalling these functions\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[23]:\n\n\n\n    \n\n\nf\n(\n42\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[23]:\n\n\n\n\n\n\n\n\n1764\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[24]:\n\n\n\n    \n\n\nf2\n(\n42\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[24]:\n\n\n\n\n\n\n\n\n1764\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[25]:\n\n\n\n    \n\n\nf3\n(\n42\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[25]:\n\n\n\n\n\n\n\n\n1764\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDuck-typing in Julia\n\"If it quacks like a duck, it's a duck.\"\n \n\nJulia functions will just work on whatever inputs make sense. \n\nFor example, \nf\n will work on a matrix.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[26]:\n\n\n\n    \n\n\nA\n \n=\n \nrand\n(\n3\n,\n \n3\n)\n\n\nA\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[26]:\n\n\n\n\n\n\n\n\n3\u00d73 Array{Float64,2}:\n 0.755473  0.327141  0.0776725\n 0.901061  0.221114  0.947983\n 0.570018  0.871543  0.612919 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[27]:\n\n\n\n    \n\n\nf\n(\nA\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[27]:\n\n\n\n\n\n\n\n\n3\u00d73 Array{Float64,2}:\n 0.909788  0.387177  0.416411\n 1.42033   1.16987   0.860637\n 1.56532   0.913372  1.24615 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOn the other hand, \nf\n will not work on a vector. Unlike \nA^2\n, which is well-defined, the meaning of \nv^2\n for a vector, \nv\n, is ambiguous.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[28]:\n\n\n\n    \n\n\nv\n \n=\n \nrand\n(\n3\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[28]:\n\n\n\n\n\n\n\n\n3-element Array{Float64,1}:\n 0.045367062724664065\n 0.04565883354805855\n 0.032975147466980825\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[29]:\n\n\n\n    \n\n\nf\n(\nv\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\nMethodError: no method matching ^(::Array{Float64,1}, ::Int64)\nClosest candidates are:\n  ^(!Matched::Float16, ::Integer) at math.jl:795\n  ^(!Matched::Missing, ::Integer) at missing.jl:120\n  ^(!Matched::Missing, ::Number) at missing.jl:93\n  ...\n\nStacktrace:\n [1] macro expansion at ./none:0 [inlined]\n [2] literal_pow at ./none:0 [inlined]\n [3] f(::Array{Float64,1}) at ./In[20]:2\n [4] top-level scope at In[29]:1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMutating vs. non-mutating functions\nBy convention, functions followed by \n!\n alter their contents and functions lacking \n!\n do not.\n\n\nFor example, let's look at the difference between \nsort\n and \nsort!\n.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[30]:\n\n\n\n    \n\n\nv\n \n=\n \n[\n3\n,\n \n5\n,\n \n2\n]\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[30]:\n\n\n\n\n\n\n\n\n3-element Array{Int64,1}:\n 3\n 5\n 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[31]:\n\n\n\n    \n\n\nsort\n(\nv\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[31]:\n\n\n\n\n\n\n\n\n3-element Array{Int64,1}:\n 2\n 3\n 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[32]:\n\n\n\n    \n\n\nv\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[32]:\n\n\n\n\n\n\n\n\n3-element Array{Int64,1}:\n 3\n 5\n 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsort(v)\n returns a sorted array that contains the same elements as \nv\n, but \nv\n is left unchanged. \n\n\nOn the other hand, when we run \nsort!(v)\n, the contents of v are sorted within the array \nv\n.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[33]:\n\n\n\n    \n\n\nsort!\n(\nv\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[33]:\n\n\n\n\n\n\n\n\n3-element Array{Int64,1}:\n 2\n 3\n 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[34]:\n\n\n\n    \n\n\nv\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[34]:\n\n\n\n\n\n\n\n\n3-element Array{Int64,1}:\n 2\n 3\n 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSome higher order functions\nmap\nmap\n is a \"higher-order\" function in Julia that \ntakes a function\n as one of its input arguments.\n\nmap\n then applies that function to every element of the data structure you pass it. For example, executing\n\n\nmap\n(\nf\n,\n \n[\n1\n,\n \n2\n,\n \n3\n])\n\n\n\n\nwill give you an output array where the function \nf\n has been applied to all elements of \n[1, 2, 3]\n\n\n[\nf\n(\n1\n),\n \nf\n(\n2\n),\n \nf\n(\n3\n)]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[35]:\n\n\n\n    \n\n\nmap\n(\nf\n,\n \n[\n1\n,\n \n2\n,\n \n3\n])\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[35]:\n\n\n\n\n\n\n\n\n3-element Array{Int64,1}:\n 1\n 4\n 9\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHere we've squared all the elements of the vector \n[1, 2, 3]\n, rather than squaring the vector \n[1, 2, 3]\n.\n\n\nTo do this, we could have passed to \nmap\n an anonymous function rather than a named function, such as\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[36]:\n\n\n\n    \n\n\nx\n \n-\n \nx\n^\n3\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[36]:\n\n\n\n\n\n\n\n\n#5 (generic function with 1 method)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvia\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[37]:\n\n\n\n    \n\n\nmap\n(\nx\n \n-\n \nx\n^\n3\n,\n \n[\n1\n,\n \n2\n,\n \n3\n])\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[37]:\n\n\n\n\n\n\n\n\n3-element Array{Int64,1}:\n  1\n  8\n 27\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nand now we've cubed all the elements of \n[1, 2, 3]\n!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbroadcast\nbroadcast\n is another higher-order function like \nmap\n. \nbroadcast\n is a generalization of \nmap\n, so it can do every thing \nmap\n can do and more. The syntax for calling \nbroadcast\n is the same as for calling \nmap\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[38]:\n\n\n\n    \n\n\nbroadcast\n(\nf\n,\n \n[\n1\n,\n \n2\n,\n \n3\n])\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[38]:\n\n\n\n\n\n\n\n\n3-element Array{Int64,1}:\n 1\n 4\n 9\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nand again, we've applied \nf\n (squared) to all the elements of \n[1, 2, 3]\n - this time by \"broadcasting\" \nf\n!\n\n\nSome syntactic sugar for calling \nbroadcast\n is to place a \n.\n between the name of the function you want to \nbroadcast\n and its input arguments. For example,\n\n\nbroadcast\n(\nf\n,\n \n[\n1\n,\n \n2\n,\n \n3\n])\n\n\n\n\nis the same as\n\n\nf\n.\n([\n1\n,\n \n2\n,\n \n3\n])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[39]:\n\n\n\n    \n\n\nf\n.\n([\n1\n,\n \n2\n,\n \n3\n])\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[39]:\n\n\n\n\n\n\n\n\n3-element Array{Int64,1}:\n 1\n 4\n 9\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotice again how different this is from calling\n\n\nf\n([\n1\n,\n \n2\n,\n \n3\n])\n\n\n\n\nWe can square every element of a vector, but we can't square a vector!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTo drive home the point, let's look at the difference between\n\n\nf\n(\nA\n)\n\n\n\n\nand\n\n\nf\n.\n(\nA\n)\n\n\n\n\nfor a matrix \nA\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[40]:\n\n\n\n    \n\n\nA\n \n=\n \n[\ni\n \n+\n \n3\n*\nj\n \nfor\n \nj\n \nin\n \n0\n:\n2\n,\n \ni\n \nin\n \n1\n:\n3\n]\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[40]:\n\n\n\n\n\n\n\n\n3\u00d73 Array{Int64,2}:\n 1  2  3\n 4  5  6\n 7  8  9\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[41]:\n\n\n\n    \n\n\nf\n(\nA\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[41]:\n\n\n\n\n\n\n\n\n3\u00d73 Array{Int64,2}:\n  30   36   42\n  66   81   96\n 102  126  150\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAs before we see that for a matrix, \nA\n,\n\n\n\nf(A) = A^2 = A * A\n\n\nOn the other hand,\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[42]:\n\n\n\n    \n\n\nB\n \n=\n \nf\n.\n(\nA\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[42]:\n\n\n\n\n\n\n\n\n3\u00d73 Array{Int64,2}:\n  1   4   9\n 16  25  36\n 49  64  81\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontains the squares of all the entries of \nA\n.\n\n\nThis dot syntax for broadcasting allows us to write relatively complex compound elementwise expressions in a way that looks natural/closer to mathematical notation. For example, we can write\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[43]:\n\n\n\n    \n\n\nC\n \n=\n \nA\n \n.+\n \n2\n \n.*\n \nf\n.\n(\nA\n)\n \n./\n \nA\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[43]:\n\n\n\n\n\n\n\n\n3\u00d73 Array{Float64,2}:\n  3.0   6.0   9.0\n 12.0  15.0  18.0\n 21.0  24.0  27.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ninstead of\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn\n[44]:\n\n\n\n    \n\n\nbroadcast\n(\nx\n \n-\n \nx\n \n+\n \n2\n \n*\n \nf\n(\nx\n)\n \n/\n \nx\n,\n \nA\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nOut[44]:\n\n\n\n\n\n\n\n\n3\u00d73 Array{Float64,2}:\n  3.0   6.0   9.0\n 12.0  15.0  18.0\n 21.0  24.0  27.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nand this will still compile down to code that runs as efficiently as \nC\n!", 
            "title": "Intro"
        }, 
        {
            "location": "/tutorials/02.Linear_Algebra/", 
            "text": "Linear algebra in Julia\nBased on work by Andreas Noack Jensen\n\n\nBasic linalg ops\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFirst let's define a random matrix\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nA\n \n=\n \nrand\n(\n1\n:\n4\n,\n3\n,\n3\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n3\u00d73 Array{Int64,2}:\n 1  3  2\n 4  1  3\n 2  1  1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDefine a vector of ones\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nx\n \n=\n \nfill\n(\n1.0\n,\n \n(\n3\n))\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n3-element Array{Float64,1}:\n 1.0\n 1.0\n 1.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotice that $A$ has type Array{Int64,2} but $x$ has type Array{Float64,1}. Julia defines the aliases Vector{Type}=Array{Type,1} and Matrix{Type}=Array{Type,2}.\n\n\nMany of the basic operations are the same as in other languages\n\n\nMultiplication\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nb\n \n=\n \nA\n*\nx\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n3-element Array{Float64,1}:\n 6.0\n 8.0\n 4.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTransposition\nAs in other languages \nA'\n is the conjugate transpose\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nA\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n3\u00d73 LinearAlgebra.Adjoint{Int64,Array{Int64,2}}:\n 1  4  2\n 3  1  1\n 2  3  1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nand we can get the transpose with\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\ntranspose\n(\nA\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n3\u00d73 LinearAlgebra.Transpose{Int64,Array{Int64,2}}:\n 1  4  2\n 3  1  1\n 2  3  1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTransposed multiplication\nJulia allows us to write this without *\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nA\nA\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n3\u00d73 Array{Int64,2}:\n 21   9  16\n  9  11  10\n 16  10  14\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSolving linear systems\nThe problem $Ax=b$ for \nsquare\n $A$ is solved by the \\ function.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nA\n\\\nb\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n3-element Array{Float64,1}:\n 1.0000000000000009\n 1.0000000000000002\n 0.9999999999999993\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSpecial Matrix Structures\nMatrix structure is very important in linear algebra. To see \nhow\n important it is, let's work with a larger linear system. Use the LinearAlgebra standard package to get access to structured matrices:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nusing\n \nLinearAlgebra\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nn\n \n=\n \n1000\n\n\nA\n \n=\n \nrandn\n(\nn\n,\nn\n);\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nJulia can often infer special matrix structure\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nAsym\n \n=\n \nA\n \n+\n \nA\n\n\nissymmetric\n(\nAsym\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\ntrue\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbut sometimes floating point error might get in the way.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nAsym_noisy\n \n=\n \ncopy\n(\nAsym\n)\n\n\nAsym_noisy\n[\n1\n,\n2\n]\n \n+=\n \n5\neps\n()\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n-1.2318173450046868\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nissymmetric\n(\nAsym_noisy\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nfalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLuckily we can declare structure explicitly with, for example, \nDiagonal\n, \nTriangular\n, \nSymmetric\n, \nHermitian\n, \nTridiagonal\n and \nSymTridiagonal\n.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nAsym_explicit\n \n=\n \nSymmetric\n(\nAsym_noisy\n);\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLet's compare how long it takes Julia to compute the eigenvalues of \nAsym\n, \nAsym_noisy\n, and \nAsym_explicit\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\n@time\n \neigvals\n(\nAsym\n);\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n  0.941590 seconds (781.73 k allocations: 45.239 MiB, 9.96% gc time)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\n@time\n \neigvals\n(\nAsym_noisy\n);\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n  3.005748 seconds (18 allocations: 7.921 MiB)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\n@time\n \neigvals\n(\nAsym_explicit\n);\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n  0.246433 seconds (7.61 k allocations: 8.378 MiB, 2.28% gc time)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn this example, using \nSymmetric()\n on \nAsym_noisy\n made our calculations about \n5x\n more efficient :)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA big problem\nUsing the \nTridiagonal\n and \nSymTridiagonal\n types to store tridiagonal matrices makes it possible to work with potentially very large tridiagonal problems. The following problem would not be possible to solve on a laptop if the matrix had to be stored as a (dense) \nMatrix\n type.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nn\n \n=\n \n1_000_000\n;\n\n\nA\n \n=\n \nSymTridiagonal\n(\nrandn\n(\nn\n),\n \nrandn\n(\nn\n-\n1\n));\n\n\n@time\n \neigmax\n(\nA\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n  1.584332 seconds (520.71 k allocations: 208.447 MiB, 6.94% gc time)\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n6.128348996321588", 
            "title": "Linear Algebra"
        }, 
        {
            "location": "/tutorials/03.Using_packages/", 
            "text": "Packages\nJulia has over 2000 registered packages, making packages a huge part of the Julia ecosystem.\n\n\nEven so, the package ecosystem still has some growing to do. Notably, we have first class function calls  to other languages, providing excellent foreign function interfaces. We can easily call into python or R, for example, with \nPyCall\n or \nRcall\n.\n\n\nThis means that you don't have to wait until the Julia ecosystem is fully mature, and that moving to Julia doesn't mean you have to give up your favorite package/library from another language!\n\n\nTo see all available packages, check out\n\n\nhttps://pkg.julialang.org/\n\nor\n\nhttps://juliaobserver.com/\n\n\nFor now, let's learn how to use a package.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe first time you use a package on a given Julia installation, you need to use the package manager to explicitly add it:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nusing\n \nPkg\n\n\nPkg\n.\nadd\n(\nExample\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n  Updating\n registry at `~/.julia/registries/General`\n\n  Updating\n git-repo `https://github.com/JuliaRegistries/General.git`\n\n Resolving\n package versions...\n\n  Updating\n `~/.julia/environments/v1.0/Project.toml`\n \n [7876af07]\n + Example v0.5.1\n\n\n  Updating\n `~/.julia/environments/v1.0/Manifest.toml`\n \n [7876af07]\n + Example v0.5.1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEvery time you use Julia (start a new session at the REPL, or open a notebook for the first time, for example), you load the package with the \nusing\n keyword\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nusing\n \nExample\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\u250c Info: Precompiling Example [7876af07-990d-54b4-ab0e-23690620f79a]\n\u2514 @ Base loading.jl:1189\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn the source code of \nExample.jl\n at\n\nhttps://github.com/JuliaLang/Example.jl/blob/master/src/Example.jl\n\nwe see the following function declared\n\n\n\nhello(who::String) = \"Hello, $who\"\n\n\nHaving loaded \nExample\n, we should now be able to call \nhello\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nhello\n(\nit\ns me. I was wondering if after all these years you\nd like to meet.\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nHello, it\ns me. I was wondering if after all these years you\nd like to meet.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNow let's play with the Colors package\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nPkg\n.\nadd\n(\nColors\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n Resolving\n package versions...\n\n  Updating\n `~/.julia/environments/v1.0/Project.toml`\n\n [no changes]\n\n\n  Updating\n `~/.julia/environments/v1.0/Manifest.toml`\n\n [no changes]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nusing\n \nColors\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLet's create a palette of 100 different colors\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\npalette\n \n=\n \ndistinguishable_colors\n(\n100\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nand then we can create a randomly checkered matrix using the \nrand\n command\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nrand\n(\n3\n,\n \n3\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n3\u00d73 Array{Float64,2}:\n 0.795049  0.705551  0.986574\n 0.699097  0.898558  0.789346\n 0.22399   0.127905  0.170703\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nrand\n(\n1\n:\n10\n,\n \n3\n,\n \n3\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n3\u00d73 Array{Int64,2}:\n 7  5  2\n 7  8  7\n 8  8  4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nrand\n(\npalette\n,\n \n3\n,\n \n3\n)", 
            "title": "Using Packages"
        }, 
        {
            "location": "/tutorials/04.Intro_to_plotting/", 
            "text": "Intro to plotting in Julia\nThere are a few different ways to plot in Julia (including calling PyPlot). \n\n\nHere we'll show you how to use \nPlots.jl\n.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nusing\n \nPkg\n;\n \nPkg\n.\nadd\n(\nPlots\n)\n\n\nusing\n \nPlots\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n  Updating\n registry at `~/.julia/registries/General`\n\n  Updating\n git-repo `https://github.com/JuliaRegistries/General.git`\n\n Resolving\n package versions...\n\n  Updating\n `~/.julia/environments/v1.0/Project.toml`\n\n [no changes]\n\n\n  Updating\n `~/.julia/environments/v1.0/Manifest.toml`\n\n [no changes]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOne of the advantages to \nPlots.jl\n is that it allows you to seamlessly change backends. In this notebook, we'll try out the \ngr()\n and \nplotlyjs()\n backends.\n\n\nIn the name of scientific inquiry, let's use this notebook to examine the relationship between the global temperature and the number of pirates between roughly 1860 and 2000.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nglobaltemperatures\n \n=\n \n[\n14.4\n,\n \n14.5\n,\n \n14.8\n,\n \n15.2\n,\n \n15.5\n,\n \n15.8\n]\n\n\nnumpirates\n \n=\n \n[\n45000\n,\n \n20000\n,\n \n15000\n,\n \n5000\n,\n \n400\n,\n \n17\n]\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n6-element Array{Int64,1}:\n 45000\n 20000\n 15000\n  5000\n   400\n    17\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTo get plotting, let's load the GR backend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\ngr\n()\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nPlots.GRBackend()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nand now we can use commands like \nplot\n and \nscatter\n to generate plots.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nplot\n(\nnumpirates\n,\n \nglobaltemperatures\n,\n \nlabel\n=\nline\n)\n  \n\nscatter!\n(\nnumpirates\n,\n \nglobaltemperatures\n,\n \nlabel\n=\npoints\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n    \n\n  \n\n\n\n\n\n  \n\n    \n\n  \n\n\n\n\n\n\n\n  \n\n    \n\n  \n\n\n\n\n\n\n\n  \n\n    \n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n\n\n\n\n1\u00d710\n\n\n\n\n\n\n4\n\n\n\n\n\n\n2\u00d710\n\n\n\n\n\n\n4\n\n\n\n\n\n\n3\u00d710\n\n\n\n\n\n\n4\n\n\n\n\n\n\n4\u00d710\n\n\n\n\n\n\n4\n\n\n\n\n\n\n14.50\n\n\n\n\n\n\n14.75\n\n\n\n\n\n\n15.00\n\n\n\n\n\n\n15.25\n\n\n\n\n\n\n15.50\n\n\n\n\n\n\n15.75\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nline\n\n\n\n\n\n\n\n\n\n\npoints\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe \n!\n at the end of the \nscatter!\n function name makes \nscatter!\n a mutating function, indicating that the scattered points will be added onto the pre-existing plot.\n\n\nIn contrast, see what happens when you replace \nscatter!\n in the above with the non-mutating function \nscatter\n.\n\n\nNext, let's update this plot with the \nxlabel!\n, \nylabel!\n, and \ntitle!\n commands to add more information to our plot.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nxlabel!\n(\nNumber of Pirates [Approximate]\n)\n\n\nylabel!\n(\nGlobal Temperature (C)\n)\n\n\ntitle!\n(\nInfluence of pirate population on global warming\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n    \n\n  \n\n\n\n\n\n  \n\n    \n\n  \n\n\n\n\n\n\n\n  \n\n    \n\n  \n\n\n\n\n\n\n\n  \n\n    \n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n\n\n\n\n1\u00d710\n\n\n\n\n\n\n4\n\n\n\n\n\n\n2\u00d710\n\n\n\n\n\n\n4\n\n\n\n\n\n\n3\u00d710\n\n\n\n\n\n\n4\n\n\n\n\n\n\n4\u00d710\n\n\n\n\n\n\n4\n\n\n\n\n\n\n14.50\n\n\n\n\n\n\n14.75\n\n\n\n\n\n\n15.00\n\n\n\n\n\n\n15.25\n\n\n\n\n\n\n15.50\n\n\n\n\n\n\n15.75\n\n\n\n\n\n\nInfluence of pirate population on global warming\n\n\n\n\n\n\nNumber of Pirates [Approximate]\n\n\n\n\n\n\nGlobal Temperature (C)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nline\n\n\n\n\n\n\n\n\n\n\npoints\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis still doesn't look quite right. The number of pirates has decreased since 1860, so reading the plot from left to right is like looking backwards in time rather than forwards. Let's flip the x axis to better see how pirate populations have caused global temperatures to change over time!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nxflip!\n()\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n    \n\n  \n\n\n\n\n\n  \n\n    \n\n  \n\n\n\n\n\n\n\n  \n\n    \n\n  \n\n\n\n\n\n\n\n  \n\n    \n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n\n\n\n\n1\u00d710\n\n\n\n\n\n\n4\n\n\n\n\n\n\n2\u00d710\n\n\n\n\n\n\n4\n\n\n\n\n\n\n3\u00d710\n\n\n\n\n\n\n4\n\n\n\n\n\n\n4\u00d710\n\n\n\n\n\n\n4\n\n\n\n\n\n\n14.50\n\n\n\n\n\n\n14.75\n\n\n\n\n\n\n15.00\n\n\n\n\n\n\n15.25\n\n\n\n\n\n\n15.50\n\n\n\n\n\n\n15.75\n\n\n\n\n\n\nInfluence of pirate population on global warming\n\n\n\n\n\n\nNumber of Pirates [Approximate]\n\n\n\n\n\n\nGlobal Temperature (C)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nline\n\n\n\n\n\n\n\n\n\n\npoints\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnd there we have it!\n\n\nNote: We've had some confusion about this exercise. :) This is a joke about how people often conflate correlation and causation.\n\n\nWithout changing syntax, we can create this plot with the \nunicodeplots()\n backend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nusing\n \nPkg\n;\n \nPkg\n.\nadd\n(\nUnicodePlots\n)\n\n\nunicodeplots\n()\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n Resolving\n package versions...\n\n  Updating\n `~/.julia/environments/v1.0/Project.toml`\n \n [b8865327]\n + UnicodePlots v0.3.1\n\n\n  Updating\n `~/.julia/environments/v1.0/Manifest.toml`\n \n [b8865327]\n + UnicodePlots v0.3.1\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\u250c Info: Recompiling stale cache file /home/raphaelb/.julia/compiled/v1.0/UnicodePlots/Ctj9q.ji for UnicodePlots [b8865327-cd53-5732-bb35-84acbb429228]\n\u2514 @ Base loading.jl:1187\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nPlots.UnicodePlotsBackend()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nplot\n(\nnumpirates\n,\n \nglobaltemperatures\n,\n \nlabel\n=\nline\n)\n  \n\nscatter!\n(\nnumpirates\n,\n \nglobaltemperatures\n,\n \nlabel\n=\npoints\n)\n \n\nxlabel!\n(\nNumber of Pirates [Approximate]\n)\n\n\nylabel!\n(\nGlobal Temperature (C)\n)\n\n\ntitle!\n(\nInfluence of pirate population on global warming\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n                                   Influence of pirate population on global warming\n                             +------------------------------------------------------------+       \n                          16 |          ,                                                 | line  \n                             |          |                                                 | points\n                             |          |                                                 |       \n                             |          |                                                 |       \n                             |          |                                                 |       \n                             |          F.                                                |       \n                             |          | \\.                                              |       \n                             |          |  \n.                                             |       \n                             |          |    \n..                                          |       \n   Global Temperature (C)    |          |      \n`.                                        |       \n                             |          |         \n-.                                     |       \n                             |          |           \n\\..                                  |       \n                             |          |              \\.                                 |       \n                             |          |                `.                               |       \n                             |          |                 \n.                              |       \n                             |          |                   \n`-------.________.    |       \n                             |          |                                                 |       \n                             |          |                                                 |       \n                             |          |                                                 |       \n                          14 |          |                                                 |       \n                             +------------------------------------------------------------+       \n                             -10000                                                   50000\n                                            Number of Pirates [Approximate]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnd notice how this second plot differs from the first!", 
            "title": "Plotting"
        }, 
        {
            "location": "/tutorials/05.Julia_is_fast/", 
            "text": "Julia is fast\nVery often, benchmarks are used to compare languages.  These benchmarks can lead to long discussions, first as to exactly what is being benchmarked and secondly what explains the differences.  These simple questions can sometimes get more complicated than you at first might imagine.\n\n\nThe purpose of this notebook is for you to see a simple benchmark for yourself.  One can read the notebook and see what happened on the author's Macbook Pro with a 4-core Intel Core I7, or run the notebook yourself.\n\n\n(This material began life as a wonderful lecture by Steven Johnson at MIT: \nhttps://github.com/stevengj/18S096/blob/master/lectures/lecture1/Boxes-and-registers.ipynb\n.)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOutline of this notebook\n\n\nDefine the sum function\n\n\nImplementations \n benchmarking of sum in...\n\n\nC (hand-written)\n\n\nC (hand-written with -ffast-math)\n\n\npython (built-in)\n\n\npython (numpy)\n\n\npython (hand-written)\n\n\nJulia (built-in)\n\n\nJulia (hand-written)\n\n\nJulia (hand-written with SIMD)\n\n\n\n\n\n\nSummary of benchmarks\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsum\n: An easy enough function to understand\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConsider the  \nsum\n function \nsum(a)\n, which computes\n$$\n\\mathrm{sum}(a) = \\sum_{i=1}^n a_i,\n$$\nwhere $n$ is the length of \na\n.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\na\n \n=\n \nrand\n(\n10\n^\n7\n)\n \n# 1D vector of random numbers, uniform on [0,1)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n10000000-element Array{Float64,1}:\n 0.7555525224966515 \n 0.7226421600954749 \n 0.3686849691568155 \n 0.4391369644148555 \n 0.18818238616851368\n 0.6875689453735636 \n 0.5929445351462672 \n 0.40636884349970015\n 0.11416186640347914\n 0.5346301360597583 \n 0.1864661845374891 \n 0.3635838460941345 \n 0.8631905131374886 \n \u22ee                  \n 0.7347662122931133 \n 0.13757142567721248\n 0.722313542026447  \n 0.2841786989917985 \n 0.5976575850068786 \n 0.48371925795619375\n 0.612698622330109  \n 0.5633557714839461 \n 0.9525501059092432 \n 0.5132878594971972 \n 0.8089524941132771 \n 0.4567671326816063 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nsum\n(\na\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n4.999681685390142e6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe expected result is 0.5 * 10^7, since the mean of each entry is 0.5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBenchmarking a few ways in a few languages\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\n@time\n \nsum\n(\na\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n  0.005489 seconds (5 allocations: 176 bytes)\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n4.999681685390142e6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\n@time\n \nsum\n(\na\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n  0.009588 seconds (5 allocations: 176 bytes)\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n4.999681685390142e6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\n@time\n \nsum\n(\na\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n  0.009077 seconds (5 allocations: 176 bytes)\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n4.999681685390142e6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe \n@time\n macro can yield noisy results, so it's not our best choice for benchmarking!\n\n\nLuckily, Julia has a \nBenchmarkTools.jl\n package to make benchmarking easy and accurate:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\n# using Pkg\n\n\n# Pkg.add(\nBenchmarkTools\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nusing\n \nBenchmarkTools\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1. The C language\nC is often considered the gold standard: difficult on the human, nice for the machine. Getting within a factor of 2 of C is often satisfying. Nonetheless, even within C, there are many kinds of optimizations possible that a naive C writer may or may not get the advantage of.\n\n\nThe current author does not speak C, so he does not read the cell below, but is happy to know that you can put C code in a Julia session, compile it, and run it. Note that the \n\"\"\"\n wrap a multi-line string.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nusing\n \nLibdl\n\n\nC_code\n \n=\n \n\n\n#include \nstddef.h\n\n\ndouble c_sum(size_t n, double *X) {\n\n\n    double s = 0.0;\n\n\n    for (size_t i = 0; i \n n; ++i) {\n\n\n        s += X[i];\n\n\n    }\n\n\n    return s;\n\n\n}\n\n\n\n\n\nconst\n \nClib\n \n=\n \ntempname\n()\n   \n# make a temporary file\n\n\n\n\n# compile to a shared library by piping C_code to gcc\n\n\n# (works only if you have gcc installed):\n\n\n\nopen\n(\n`gcc -fPIC -O3 -msse3 -xc -shared -o \n$\n(\nClib\n \n*\n \n.\n \n*\n \nLibdl\n.\ndlext\n)\n -`\n,\n \nw\n)\n \ndo\n \nf\n\n    \nprint\n(\nf\n,\n \nC_code\n)\n \n\nend\n\n\n\n# define a Julia function that calls the C function:\n\n\nc_sum\n(\nX\n::\nArray\n{\nFloat64\n})\n \n=\n \nccall\n((\nc_sum\n,\n \nClib\n),\n \nFloat64\n,\n \n(\nCsize_t\n,\n \nPtr\n{\nFloat64\n}),\n \nlength\n(\nX\n),\n \nX\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nc_sum (generic function with 1 method)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nc_sum\n(\na\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n4.999681685389632e6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nc_sum\n(\na\n)\n \n\u2248\n \nsum\n(\na\n)\n \n# type \\approx and then \nTAB\n to get the \u2248 symbolb\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\ntrue\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nc_sum\n(\na\n)\n \n-\n \nsum\n(\na\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n-5.094334483146667e-7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\n\u2248\n  \n# alias for the `isapprox` function\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nisapprox (generic function with 8 methods)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\n?\nisapprox\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\nsearch: \ni\ns\na\np\np\nr\no\nx\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nisapprox(x, y; rtol::Real=atol\n0 ? 0 : \u221aeps, atol::Real=0, nans::Bool=false, norm::Function)\n\n\nInexact equality comparison: \ntrue\n if \nnorm(x-y) \n= max(atol, rtol*max(norm(x), norm(y)))\n. The default \natol\n is zero and the default \nrtol\n depends on the types of \nx\n and \ny\n. The keyword argument \nnans\n determines whether or not NaN values are considered equal (defaults to false).\n\n\nFor real or complex floating-point values, if an \natol \n 0\n is not specified, \nrtol\n defaults to the square root of \neps\n of the type of \nx\n or \ny\n, whichever is bigger (least precise). This corresponds to requiring equality of about half of the significand digits. Otherwise, e.g. for integer arguments or if an \natol \n 0\n is supplied, \nrtol\n defaults to zero.\n\n\nx\n and \ny\n may also be arrays of numbers, in which case \nnorm\n defaults to \nvecnorm\n but may be changed by passing a \nnorm::Function\n keyword argument. (For numbers, \nnorm\n is the same thing as \nabs\n.) When \nx\n and \ny\n are arrays, if \nnorm(x-y)\n is not finite (i.e. \n\u00b1Inf\n or \nNaN\n), the comparison falls back to checking whether all elements of \nx\n and \ny\n are approximately equal component-wise.\n\n\nThe binary operator \n\u2248\n is equivalent to \nisapprox\n with the default arguments, and \nx \u2249 y\n is equivalent to \n!isapprox(x,y)\n.\n\n\nNote that \nx \u2248 0\n (i.e., comparing to zero with the default tolerances) is equivalent to \nx == 0\n since the default \natol\n is \n0\n.  In such cases, you should either supply an appropriate \natol\n (or use \nnorm(x) \u2264 atol\n) or rearrange your code (e.g. use \nx \u2248 y\n rather than \nx - y \u2248 0\n).   It is not possible to pick a nonzero \natol\n automatically because it depends on the overall scaling (the \"units\") of your problem: for example, in \nx - y \u2248 0\n, \natol=1e-9\n is an absurdly small tolerance if \nx\n is the \nradius of the Earth\n in meters, but an absurdly large tolerance if \nx\n is the \nradius of a Hydrogen atom\n in meters.\n\n\nExamples\n\n\njldoctest\njulia\n 0.1 \u2248 (0.1 - 1e-10)\ntrue\n\njulia\n isapprox(10, 11; atol = 2)\ntrue\n\njulia\n isapprox([10.0^9, 1.0], [10.0^9, 2.0])\ntrue\n\njulia\n 1e-10 \u2248 0\nfalse\n\njulia\n isapprox(1e-10, 0, atol=1e-8)\ntrue\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can now benchmark the C code directly from Julia:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nc_bench\n \n=\n \n@benchmark\n \nc_sum\n(\n$\na\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nBenchmarkTools.Trial: \n  memory estimate:  0 bytes\n  allocs estimate:  0\n  --------------\n  minimum time:     18.692 ms (0.00% GC)\n  median time:      20.694 ms (0.00% GC)\n  mean time:        21.461 ms (0.00% GC)\n  maximum time:     29.078 ms (0.00% GC)\n  --------------\n  samples:          233\n  evals/sample:     1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nprintln\n(\nC: Fastest time was \n$\n(\nminimum\n(\nc_bench\n.\ntimes\n)\n \n/\n \n1e6\n)\n msec\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\nC: Fastest time was 18.691859 msec\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nd\n \n=\n \nDict\n()\n  \n# a \ndictionary\n, i.e. an associative array\n\n\nd\n[\nC\n]\n \n=\n \nminimum\n(\nc_bench\n.\ntimes\n)\n \n/\n \n1e6\n  \n# in milliseconds\n\n\nd\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nDict{Any,Any} with 1 entry:\n  \nC\n =\n 18.6919\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nusing\n \nPlots\n\n\ngr\n()\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nPlots.GRBackend()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nusing\n \nStatistics\n \n# bring in statistical support for standard deviations\n\n\nt\n \n=\n \nc_bench\n.\ntimes\n \n/\n \n1e6\n \n# times in milliseconds\n\n\nm\n,\n \n\u03c3\n \n=\n \nminimum\n(\nt\n),\n \nstd\n(\nt\n)\n\n\n\nhistogram\n(\nt\n,\n \nbins\n=\n500\n,\n\n    \nxlim\n=\n(\nm\n \n-\n \n0.01\n,\n \nm\n \n+\n \n\u03c3\n),\n\n    \nxlabel\n=\nmilliseconds\n,\n \nylabel\n=\ncount\n,\n \nlabel\n=\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n    \n\n  \n\n\n\n\n\n  \n\n    \n\n  \n\n\n\n\n\n\n\n  \n\n    \n\n  \n\n\n\n\n\n\n\n  \n\n    \n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n19.0\n\n\n\n\n\n\n19.5\n\n\n\n\n\n\n20.0\n\n\n\n\n\n\n20.5\n\n\n\n\n\n\n0\n\n\n\n\n\n\n2\n\n\n\n\n\n\n4\n\n\n\n\n\n\n6\n\n\n\n\n\n\nmilliseconds\n\n\n\n\n\n\ncount\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2. C with -ffast-math\nIf we allow C to re-arrange the floating point operations, then it'll vectorize with SIMD (single instruction, multiple data) instructions.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nconst\n \nClib_fastmath\n \n=\n \ntempname\n()\n   \n# make a temporary file\n\n\n\n# The same as above but with a -ffast-math flag added\n\n\nopen\n(\n`gcc -fPIC -O3 -msse3 -xc -shared -ffast-math -o \n$\n(\nClib_fastmath\n \n*\n \n.\n \n*\n \nLibdl\n.\ndlext\n)\n -`\n,\n \nw\n)\n \ndo\n \nf\n\n    \nprint\n(\nf\n,\n \nC_code\n)\n \n\nend\n\n\n\n# define a Julia function that calls the C function:\n\n\nc_sum_fastmath\n(\nX\n::\nArray\n{\nFloat64\n})\n \n=\n \nccall\n((\nc_sum\n,\n \nClib_fastmath\n),\n \nFloat64\n,\n \n(\nCsize_t\n,\n \nPtr\n{\nFloat64\n}),\n \nlength\n(\nX\n),\n \nX\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nc_sum_fastmath (generic function with 1 method)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nc_fastmath_bench\n \n=\n \n@benchmark\n \n$\nc_sum_fastmath\n(\n$\na\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nBenchmarkTools.Trial: \n  memory estimate:  0 bytes\n  allocs estimate:  0\n  --------------\n  minimum time:     8.572 ms (0.00% GC)\n  median time:      9.785 ms (0.00% GC)\n  mean time:        10.210 ms (0.00% GC)\n  maximum time:     14.546 ms (0.00% GC)\n  --------------\n  samples:          489\n  evals/sample:     1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nd\n[\nC -ffast-math\n]\n \n=\n \nminimum\n(\nc_fastmath_bench\n.\ntimes\n)\n \n/\n \n1e6\n  \n# in milliseconds\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n8.571663\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3. Python's built in \nsum\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe \nPyCall\n package provides a Julia interface to Python:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\n# using Pkg; Pkg.add(\nPyCall\n)\n\n\nusing\n \nPyCall\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\n# get the Python built-in \nsum\n function:\n\n\npysum\n \n=\n \npybuiltin\n(\nsum\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nPyObject \nbuilt-in function sum\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\npysum\n(\na\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n4.999681685389632e6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\npysum\n(\na\n)\n \n\u2248\n \nsum\n(\na\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\ntrue\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\npy_list_bench\n \n=\n \n@benchmark\n \n$\npysum\n(\n$\na\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nBenchmarkTools.Trial: \n  memory estimate:  152.60 MiB\n  allocs estimate:  10000054\n  --------------\n  minimum time:     1.393 s (34.20% GC)\n  median time:      1.875 s (35.76% GC)\n  mean time:        1.898 s (34.96% GC)\n  maximum time:     2.424 s (34.77% GC)\n  --------------\n  samples:          3\n  evals/sample:     1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nd\n[\nPython built-in\n]\n \n=\n \nminimum\n(\npy_list_bench\n.\ntimes\n)\n \n/\n \n1e6\n\n\nd\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nDict{Any,Any} with 3 entries:\n  \nC\n               =\n 18.6919\n  \nPython built-in\n =\n 1392.92\n  \nC -ffast-math\n   =\n 8.57166\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4. Python: \nnumpy\nTakes advantage of hardware \"SIMD\", but only works when it works.\nnumpy\n is an optimized C library, callable from Python.\nIt may be installed within Julia as follows:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nusing\n \nPkg\n;\n \nPkg\n.\nadd\n(\nConda\n)\n\n\nusing\n \nConda\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n  Updating\n registry at `~/.julia/registries/General`\n\n  Updating\n git-repo `https://github.com/JuliaRegistries/General.git`\n\n Resolving\n package versions...\n\n  Updating\n `~/.julia/environments/v1.0/Project.toml`\n\n [no changes]\n\n\n  Updating\n `~/.julia/environments/v1.0/Manifest.toml`\n\n [no changes]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nConda\n.\nadd\n(\nnumpy\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\u250c Info: Running `conda install -y numpy` in root environment\n\u2514 @ Conda /home/raphaelb/.julia/packages/Conda/uQitS/src/Conda.jl:112\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\nSolving environment: ...working... done\n\n# All requested packages already installed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nnumpy_sum\n \n=\n \npyimport\n(\nnumpy\n)[\nsum\n]\n\n\n\npy_numpy_bench\n \n=\n \n@benchmark\n \n$\nnumpy_sum\n(\n$\na\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nBenchmarkTools.Trial: \n  memory estimate:  368 bytes\n  allocs estimate:  8\n  --------------\n  minimum time:     4.374 ms (0.00% GC)\n  median time:      4.818 ms (0.00% GC)\n  mean time:        4.903 ms (0.00% GC)\n  maximum time:     8.200 ms (0.00% GC)\n  --------------\n  samples:          1018\n  evals/sample:     1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nnumpy_sum\n(\na\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n4.999681685390145e6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nnumpy_sum\n(\na\n)\n \n\u2248\n \nsum\n(\na\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\ntrue\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nd\n[\nPython numpy\n]\n \n=\n \nminimum\n(\npy_numpy_bench\n.\ntimes\n)\n \n/\n \n1e6\n\n\nd\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nDict{Any,Any} with 8 entries:\n  \nJulia hand-written simd\n =\n 6.22709\n  \nC\n                       =\n 18.6919\n  \nJulia hand-written\n      =\n 17.6705\n  \nPython numpy\n            =\n 4.37422\n  \nPython hand-written\n     =\n 1889.34\n  \nPython built-in\n         =\n 1392.92\n  \nJulia built-in\n          =\n 5.83222\n  \nC -ffast-math\n           =\n 8.57166\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n5. Python, hand-written\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\npy\n\n\ndef py_sum(A):\n\n\n    s = 0.0\n\n\n    for a in A:\n\n\n        s += a\n\n\n    return s\n\n\n\n\n\nsum_py\n \n=\n \npy\npy_sum\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nPyObject \nfunction py_sum at 0x7fc9d805f840\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\npy_hand\n \n=\n \n@benchmark\n \n$\nsum_py\n(\n$\na\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nBenchmarkTools.Trial: \n  memory estimate:  368 bytes\n  allocs estimate:  8\n  --------------\n  minimum time:     1.488 s (0.00% GC)\n  median time:      1.558 s (0.00% GC)\n  mean time:        1.572 s (0.00% GC)\n  maximum time:     1.683 s (0.00% GC)\n  --------------\n  samples:          4\n  evals/sample:     1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nsum_py\n(\na\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n4.999681685389632e6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nsum_py\n(\na\n)\n \n\u2248\n \nsum\n(\na\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\ntrue\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nd\n[\nPython hand-written\n]\n \n=\n \nminimum\n(\npy_hand\n.\ntimes\n)\n \n/\n \n1e6\n\n\nd\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nDict{Any,Any} with 8 entries:\n  \nJulia hand-written simd\n =\n 6.22709\n  \nC\n                       =\n 18.6919\n  \nJulia hand-written\n      =\n 17.6705\n  \nPython numpy\n            =\n 4.37422\n  \nPython hand-written\n     =\n 1488.13\n  \nPython built-in\n         =\n 1392.92\n  \nJulia built-in\n          =\n 5.83222\n  \nC -ffast-math\n           =\n 8.57166\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6. Julia (built-in)\nWritten directly in Julia, not in C!\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\n@which\n \nsum\n(\na\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\nsum(a::\nAbstractArray\n) in Base at \nreducedim.jl:645\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nj_bench\n \n=\n \n@benchmark\n \nsum\n(\n$\na\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nBenchmarkTools.Trial: \n  memory estimate:  0 bytes\n  allocs estimate:  0\n  --------------\n  minimum time:     5.955 ms (0.00% GC)\n  median time:      7.652 ms (0.00% GC)\n  mean time:        7.910 ms (0.00% GC)\n  maximum time:     12.904 ms (0.00% GC)\n  --------------\n  samples:          631\n  evals/sample:     1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nd\n[\nJulia built-in\n]\n \n=\n \nminimum\n(\nj_bench\n.\ntimes\n)\n \n/\n \n1e6\n\n\nd\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nDict{Any,Any} with 8 entries:\n  \nJulia hand-written simd\n =\n 6.22709\n  \nC\n                       =\n 18.6919\n  \nJulia hand-written\n      =\n 17.6705\n  \nPython numpy\n            =\n 4.37422\n  \nPython hand-written\n     =\n 1488.13\n  \nPython built-in\n         =\n 1392.92\n  \nJulia built-in\n          =\n 5.95542\n  \nC -ffast-math\n           =\n 8.57166\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n7. Julia (hand-written)\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nfunction\n \nmysum\n(\nA\n)\n   \n    \ns\n \n=\n \n0.0\n \n# s = zero(eltype(a))\n\n    \nfor\n \na\n \nin\n \nA\n\n        \ns\n \n+=\n \na\n\n    \nend\n\n    \ns\n\n\nend\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nmysum (generic function with 1 method)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nj_bench_hand\n \n=\n \n@benchmark\n \nmysum\n(\n$\na\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nBenchmarkTools.Trial: \n  memory estimate:  0 bytes\n  allocs estimate:  0\n  --------------\n  minimum time:     22.777 ms (0.00% GC)\n  median time:      24.510 ms (0.00% GC)\n  mean time:        24.246 ms (0.00% GC)\n  maximum time:     26.653 ms (0.00% GC)\n  --------------\n  samples:          207\n  evals/sample:     1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nd\n[\nJulia hand-written\n]\n \n=\n \nminimum\n(\nj_bench_hand\n.\ntimes\n)\n \n/\n \n1e6\n\n\nd\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nDict{Any,Any} with 8 entries:\n  \nJulia hand-written simd\n =\n 6.22709\n  \nC\n                       =\n 18.6919\n  \nJulia hand-written\n      =\n 22.7771\n  \nPython numpy\n            =\n 4.37422\n  \nPython hand-written\n     =\n 1488.13\n  \nPython built-in\n         =\n 1392.92\n  \nJulia built-in\n          =\n 5.95542\n  \nC -ffast-math\n           =\n 8.57166\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n8. Julia (hand-written w. simd)\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nfunction\n \nmysum_simd\n(\nA\n)\n   \n    \ns\n \n=\n \n0.0\n \n# s = zero(eltype(A))\n\n    \n@simd\n \nfor\n \na\n \nin\n \nA\n\n        \ns\n \n+=\n \na\n\n    \nend\n\n    \ns\n\n\nend\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nmysum_simd (generic function with 1 method)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nj_bench_hand_simd\n \n=\n \n@benchmark\n \nmysum_simd\n(\n$\na\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nBenchmarkTools.Trial: \n  memory estimate:  0 bytes\n  allocs estimate:  0\n  --------------\n  minimum time:     6.432 ms (0.00% GC)\n  median time:      10.402 ms (0.00% GC)\n  mean time:        10.445 ms (0.00% GC)\n  maximum time:     17.141 ms (0.00% GC)\n  --------------\n  samples:          478\n  evals/sample:     1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nmysum_simd\n(\na\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n4.999681685390122e6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nd\n[\nJulia hand-written simd\n]\n \n=\n \nminimum\n(\nj_bench_hand_simd\n.\ntimes\n)\n \n/\n \n1e6\n\n\nd\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nDict{Any,Any} with 8 entries:\n  \nJulia hand-written simd\n =\n 6.43202\n  \nC\n                       =\n 18.6919\n  \nJulia hand-written\n      =\n 22.7771\n  \nPython numpy\n            =\n 4.37422\n  \nPython hand-written\n     =\n 1488.13\n  \nPython built-in\n         =\n 1392.92\n  \nJulia built-in\n          =\n 5.95542\n  \nC -ffast-math\n           =\n 8.57166\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSummary\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nfor\n \n(\nkey\n,\n \nvalue\n)\n \nin\n \nsort\n(\ncollect\n(\nd\n),\n \nby\n=\nlast\n)\n\n    \nprintln\n(\nrpad\n(\nkey\n,\n \n25\n,\n \n.\n),\n \nlpad\n(\nround\n(\nvalue\n;\n \ndigits\n=\n1\n),\n \n6\n,\n \n.\n))\n\n\nend\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\nPython numpy................4.4\nJulia built-in..............6.0\nJulia hand-written simd.....6.4\nC -ffast-math...............8.6\nC..........................18.7\nJulia hand-written.........22.8\nPython built-in..........1392.9\nPython hand-written......1488.1", 
            "title": "Julia is fast"
        }, 
        {
            "location": "/tutorials/06.Multiple_dispatch/", 
            "text": "Multiple dispatch\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn this notebook we'll explore \nmultiple dispatch\n, which is a key feature of Julia.\n\n\nMultiple dispatch makes software \ngeneric\n and \nfast\n!\n\n\nStarting with the familiar\nTo understand multiple dispatch in Julia, let's start with what we've already seen.\n\n\nWe can declare functions in Julia without giving Julia any information about the types of the input arguments that function will receive:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nf\n(\nx\n)\n \n=\n \nx\n^\n2\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nf (generic function with 1 method)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nand then Julia will determine on its own which input argument types make sense and which do not:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nf\n(\n10\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\n100\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nf\n([\n1\n,\n \n2\n,\n \n3\n])\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\nMethodError: no method matching ^(::Array{Int64,1}, ::Int64)\nClosest candidates are:\n  ^(!Matched::Float16, ::Integer) at math.jl:795\n  ^(!Matched::Missing, ::Integer) at missing.jl:120\n  ^(!Matched::Missing, ::Number) at missing.jl:93\n  ...\n\nStacktrace:\n [1] macro expansion at ./none:0 [inlined]\n [2] literal_pow at ./none:0 [inlined]\n [3] f(::Array{Int64,1}) at ./In[1]:1\n [4] top-level scope at In[3]:1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSpecifying the types of our input arguments\nHowever, we also have the \noption\n to tell Julia explicitly what types our input arguments are allowed to have.\n\n\nFor example, let's write a function \nfoo\n that only takes strings as inputs.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nfoo\n(\nx\n::\nString\n,\n \ny\n::\nString\n)\n \n=\n \nprintln\n(\nMy inputs x and y are both strings!\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nfoo (generic function with 1 method)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe see here that in order to restrict the type of \nx\n and \ny\n to \nString\ns, we just follow the input argument name by a double colon and the keyword \nString\n.\n\n\nNow we'll see that \nfoo\n works on \nString\ns and doesn't work on other input argument types.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nfoo\n(\nhello\n,\n \nhi!\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\nMy inputs x and y are both strings!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nfoo\n(\n3\n,\n \n4\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\nMethodError: no method matching foo(::Int64, ::Int64)\n\nStacktrace:\n [1] top-level scope at In[6]:1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTo get \nfoo\n to work on integer (\nInt\n) inputs, let's tack \n::Int\n onto our input arguments when we declare \nfoo\n.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nfoo\n(\nx\n::\nInt\n,\n \ny\n::\nInt\n)\n \n=\n \nprintln\n(\nMy inputs x and y are both integers!\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nfoo (generic function with 2 methods)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nfoo\n(\n3\n,\n \n4\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\nMy inputs x and y are both integers!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNow \nfoo\n works on integers! But look, \nfoo\n also still works when \nx\n and \ny\n are strings!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nfoo\n(\nhello\n,\n \nhi!\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\nMy inputs x and y are both strings!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis is starting to get to the heart of multiple dispatch. When we declared\n\n\nfoo\n(\nx\n::\nInt\n,\n \ny\n::\nInt\n)\n \n=\n \nprintln\n(\nMy inputs x and y are both integers!\n)\n\n\n\n\nwe didn't overwrite or replace\n\n\nfoo\n(\ny\n::\nString\n,\n \ny\n::\nString\n)\n\n\n\n\nInstead, we just added an additional \nmethod\n to the \ngeneric function\n called \nfoo\n.\n\n\nA \ngeneric function\n is the abstract concept associated with a particular operation.\n\n\nFor example, the generic function \n+\n represents the concept of addition.\n\n\nA \nmethod\n is a specific implementation of a generic function for \nparticular argument types\n.\n\n\nFor example, \n+\n has methods that accept floating point numbers, integers, matrices, etc.\n\n\nWe can use the \nmethods\n to see how many methods there are for \nfoo\n.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nmethods\n(\nfoo\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n2 methods for generic function \nfoo\n:\n foo(x::\nInt64\n, y::\nInt64\n) in Main at In[7]:1\n \n foo(x::\nString\n, y::\nString\n) in Main at In[4]:1\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmethods(+) returns 163 methods...\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSo, we now can call \nfoo\n on integers or strings. When you call \nfoo\n on a particular set of arguments, Julia will infer the types of the inputs and dispatch the appropriate method. \nThis\n is multiple dispatch.\n\n\nMultiple dispatch makes our code generic and fast. Our code can be generic and flexible because we can write code in terms of abstract operations such as addition and multiplication, rather than in terms of specific implementations. At the same time, our code runs quickly because Julia is able to call efficient methods for the relevant types.\n\n\nTo see which method is being dispatched when we call a generic function, we can use the @which macro:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\n@which\n \nfoo\n(\n3\n,\n \n4\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\nfoo(x::\nInt64\n, y::\nInt64\n) in Main at In[7]:1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\n@which\n \n3.0\n \n+\n \n3.0\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n+(x::\nFloat64\n, y::\nFloat64\n) in Base at \nfloat.jl:395\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGiven that a method written specifically for floating point numbers is dispatched on \n3.0 + 3.0\n, the LLVM code generated is extremely terse:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\n@code_llvm\n \n3.0\n \n+\n \n3.0\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n; Function +\n; Location: float.jl:395\ndefine double @\njulia_+_34566\n(double, double) {\ntop:\n  %2 = fadd double %0, %1\n  ret double %2\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote that Julia is fast even when we write generic function definitions because, at the end of the day, specific/tailored methods are called under the hood.\n\n\nFor example, note that we can declare the adding function \nmyadd\n without providing any type annotations -\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\nmyadd\n(\nx\n,\n \ny\n)\n \n=\n \nx\n \n+\n \ny\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n\nmyadd (generic function with 1 method)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nand though we haven't constrained the types of \nx\n and \ny\n, we'll see that the LLVM code generated for \nmyadd(3.0, 3.0)\n looks like that of \n3.0 + 3.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n    \n\n\n@code_llvm\n \nmyadd\n(\n3.0\n,\n \n3.0\n)\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n \n\n\n\n\n\n\n\n; Function myadd\n; Location: In[24]:1\ndefine double @julia_myadd_35761(double, double) {\ntop:\n; Function +; {\n; Location: float.jl:395\n  %2 = fadd double %0, %1\n;}\n  ret double %2\n}", 
            "title": "Multiple dispatch"
        }, 
        {
            "location": "/interop/", 
            "text": "Interoperability with other languages\n\n\nPython\n\n\nYou can use Python packages from Julia with this Julia package : \nPycall\n\n\nExample :\n\n\njulia\n \nusing\n \nPyCall\n\n\njulia\n \n@pyimport\n \nmath\n\n\njulia\n \nmath\n.\nsin\n(\nmath\n.\npi\n \n/\n \n4\n)\n \n-\n \nsin\n(\npi\n \n/\n \n4\n)\n  \n# compares python math sin function with Julia\ns (hopefully returns 0.0)\n\n\n\n\n\n\nYou can also Julia from Python with this package : \nhttps://github.com/JuliaPy/pyjulia\n\n\nThe Julia docs provide also a \nlist of noteworthy differences\n that have to be taken care of when coming from Python.\n\n\nR\n\n\nYou can use R packages from Julia with this Julia package : \nRCall\n\n\nExample :\n\n\njulia\n \nusing\n \nRCall\n\n\njulia\n \nfoo\n \n=\n \n1\n\n\n1\n\n\n\nR\n \nx\n \n-\n \n$\nfoo\n \n# by just pressing `$` we switch to R console !\n\n\n\nR\n \nx\n\n\n[\n1\n]\n \n1\n\n\n\n\n\n\nThe Julia docs provide also a \nlist of noteworthy differences\n that have to be taken care of when coming from Python.\n\n\nBut also Matlab, C, C++, Java\n\n\n\n\nMatlab : \nhttps://github.com/JuliaInterop/MATLAB.jl\n and \nhttps://docs.julialang.org/en/latest/manual/noteworthy-differences/#Noteworthy-differences-from-MATLAB-1\n\n\nC with no overhead using FFI  \n\n\n...", 
            "title": "Interop with other languages"
        }, 
        {
            "location": "/interop/#interoperability-with-other-languages", 
            "text": "", 
            "title": "Interoperability with other languages"
        }, 
        {
            "location": "/interop/#python", 
            "text": "You can use Python packages from Julia with this Julia package :  Pycall  Example :  julia   using   PyCall  julia   @pyimport   math  julia   math . sin ( math . pi   /   4 )   -   sin ( pi   /   4 )    # compares python math sin function with Julia s (hopefully returns 0.0)   You can also Julia from Python with this package :  https://github.com/JuliaPy/pyjulia  The Julia docs provide also a  list of noteworthy differences  that have to be taken care of when coming from Python.", 
            "title": "Python"
        }, 
        {
            "location": "/interop/#r", 
            "text": "You can use R packages from Julia with this Julia package :  RCall  Example :  julia   using   RCall  julia   foo   =   1  1  R   x   -   $ foo   # by just pressing `$` we switch to R console !  R   x  [ 1 ]   1   The Julia docs provide also a  list of noteworthy differences  that have to be taken care of when coming from Python.", 
            "title": "R"
        }, 
        {
            "location": "/interop/#but-also-matlab-c-c-java", 
            "text": "Matlab :  https://github.com/JuliaInterop/MATLAB.jl  and  https://docs.julialang.org/en/latest/manual/noteworthy-differences/#Noteworthy-differences-from-MATLAB-1  C with no overhead using FFI    ...", 
            "title": "But also Matlab, C, C++, Java"
        }, 
        {
            "location": "/examples/", 
            "text": "Various scientific domains examples\n\n\nFrom the Julia \nwebsite\n\n\nJulia is designed from the ground up to be very good at numerical and scientific computing. This can be seen in the abundance of scientific tooling written in Julia, such as the state-of-the-art differential equations ecosystem ([DifferentialEquations.jl](https://github.com/JuliaDiffEq/DifferentialEquations.jl)), optimization tools ([JuMP.jl](https://github.com/JuliaOpt/JuMP.jl) and [Optim.jl](http://julianlsolvers.github.io/Optim.jl/stable/)), iterative linear solvers ([IterativeSolvers.jl](https://github.com/JuliaMath/IterativeSolvers.jl)) and many more, that can drive all your simulations.\nJulia also offers a number of domain-specific ecosystems, such as in biology ([BioJulia](https://github.com/BioJulia)), operations research ([JuliaOpt](https://www.juliaopt.org/)), quantum physics ([QuantumOptics](https://github.com/qojulia/QuantumOptics.jl)), nonlinear dynamics ([JuliaDynamics](https://github.com/JuliaDynamics)), quantitative economics ([QuantEcon](https://github.com/QuantEcon)), astronomy ([JuliaAstro](http://juliaastro.github.io/)) and ecology ([EcoJulia](https://github.com/EcoJulia)).\n\n\n\n\n\nBelow are some examples of scientific applications using Jula\n\n\nEconomy\n\n\n\n\nQuantEcon \nhttps://quantecon.org/\n\n\nEstimating Non-Linear Macroeconomic Models at the New York Fed \nhttps://www.youtube.com/watch?v=dFyr8U-SY2M\n\n\n\n\nBioinformatics\n\n\n\n\nBioJulia: \nhttps://www.youtube.com/watch?v=6CpPd6tkokQ\n\n\nMitos (Mutual Information Tools for protein sequence analysis in Julia language) :  \nhttps://www.youtube.com/watch?v=6L2TGeeLw9g\n\n\nUnraveling lymphoma tumor microenvironment interactions with Julia \nhttps://www.youtube.com/watch?v=NQSpMtXaMFQ\n\n\n\n\nEcology/Biodiversity\n\n\n\n\nJulia Ecology group EcoJulia : \nhttps://www.youtube.com/watch?v=R4GzK-by0ac\n\n\nSimulating global plant biodiversity \nhttps://www.youtube.com/watch?v=EahBURR9b1U\n\n\n\n\nStats\n\n\n\n\nJuliaStats : \nhttp://juliastats.github.io/\n\n\nMultiple Testing \nhttps://github.com/juliangehring/MultipleTesting.jl\n\n\n\n\nImages\n\n\n\n\nJulia Images processing group \nhttp://juliaimages.github.io", 
            "title": "Scientific applications"
        }, 
        {
            "location": "/examples/#various-scientific-domains-examples", 
            "text": "From the Julia  website  Julia is designed from the ground up to be very good at numerical and scientific computing. This can be seen in the abundance of scientific tooling written in Julia, such as the state-of-the-art differential equations ecosystem ([DifferentialEquations.jl](https://github.com/JuliaDiffEq/DifferentialEquations.jl)), optimization tools ([JuMP.jl](https://github.com/JuliaOpt/JuMP.jl) and [Optim.jl](http://julianlsolvers.github.io/Optim.jl/stable/)), iterative linear solvers ([IterativeSolvers.jl](https://github.com/JuliaMath/IterativeSolvers.jl)) and many more, that can drive all your simulations.\nJulia also offers a number of domain-specific ecosystems, such as in biology ([BioJulia](https://github.com/BioJulia)), operations research ([JuliaOpt](https://www.juliaopt.org/)), quantum physics ([QuantumOptics](https://github.com/qojulia/QuantumOptics.jl)), nonlinear dynamics ([JuliaDynamics](https://github.com/JuliaDynamics)), quantitative economics ([QuantEcon](https://github.com/QuantEcon)), astronomy ([JuliaAstro](http://juliaastro.github.io/)) and ecology ([EcoJulia](https://github.com/EcoJulia)).  Below are some examples of scientific applications using Jula", 
            "title": "Various scientific domains examples"
        }, 
        {
            "location": "/examples/#economy", 
            "text": "QuantEcon  https://quantecon.org/  Estimating Non-Linear Macroeconomic Models at the New York Fed  https://www.youtube.com/watch?v=dFyr8U-SY2M", 
            "title": "Economy"
        }, 
        {
            "location": "/examples/#bioinformatics", 
            "text": "BioJulia:  https://www.youtube.com/watch?v=6CpPd6tkokQ  Mitos (Mutual Information Tools for protein sequence analysis in Julia language) :   https://www.youtube.com/watch?v=6L2TGeeLw9g  Unraveling lymphoma tumor microenvironment interactions with Julia  https://www.youtube.com/watch?v=NQSpMtXaMFQ", 
            "title": "Bioinformatics"
        }, 
        {
            "location": "/examples/#ecologybiodiversity", 
            "text": "Julia Ecology group EcoJulia :  https://www.youtube.com/watch?v=R4GzK-by0ac  Simulating global plant biodiversity  https://www.youtube.com/watch?v=EahBURR9b1U", 
            "title": "Ecology/Biodiversity"
        }, 
        {
            "location": "/examples/#stats", 
            "text": "JuliaStats :  http://juliastats.github.io/  Multiple Testing  https://github.com/juliangehring/MultipleTesting.jl", 
            "title": "Stats"
        }, 
        {
            "location": "/examples/#images", 
            "text": "Julia Images processing group  http://juliaimages.github.io", 
            "title": "Images"
        }
    ]
}